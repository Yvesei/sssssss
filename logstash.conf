input {
  beats {
    port => 5044
  }
}

filter {
  # Parse NCSA HTTP access logs
  grok {
    match => {
      "message" => '%{IP:client_ip} - %{DATA:user} \[%{HTTPDATE:timestamp}\] "%{WORD:method} %{DATA:request} HTTP/%{NUMBER:http_version}" %{NUMBER:response_code} %{NUMBER:response_size} "%{DATA:referer}" "%{DATA:user_agent}"'
    }
  }

  mutate {
    convert => {
      "response_code" => "integer"
      "response_size" => "integer"
      "http_version" => "float"
    }
    add_field => { "type" => "http_request" }
  }

  # Parse timestamp
  date {
    match => ["timestamp", "dd/MMM/yyyy:HH:mm:ss Z"]
    target => "@timestamp"
  }

  # Annotate attacks based on user_agent
  ruby {
    code => "
      ua = event.get('user_agent') || ''
      attack = 'normal'

      if ua.include?('xss')
        attack = 'XSS_Attack'
      elsif ua.include?('sqli')
        attack = 'SQLi_Attack'
      elsif ua.include?('command-injection')
        attack = 'Command_Injection'
      elsif ua.include?('path-traversal')
        attack = 'Path_Traversal'
      elsif ua.include?('jenkins')
        attack = 'Jenkins_Specific'
      end

      event.set('attack_annotation', attack)
    "
  }

  # Populate MITRE CAR format fields
  mutate {
    add_field => {
      "car_id"   => "%{client_ip}-%{@timestamp}"
      "car_type" => "activity"
      "actor"    => "%{client_ip}"
      "object"   => "%{request}"
      "action"   => "%{method}"
      "attack"   => "%{attack_annotation}"
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "jenkins-logs-car-%{+YYYY.MM.dd}"
  }
}