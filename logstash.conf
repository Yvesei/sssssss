input {
  file {
    path => "/var/log/jenkins/*.log"
    start_position => "beginning"
    ignore_older => 0
  }
}

filter {
  # Parse HTTP access logs
  grok {
    match => {
      "message" => "%{IP:client_ip} - %{DATA:user} \[%{HTTPDATE:timestamp}\] \"%{WORD:method} %{DATA:request} HTTP/%{NUMBER:http_version}\" %{NUMBER:response_code} %{NUMBER:response_size}"
    }
    tag_on_failure => []
  }
  
  # Parse Jenkins logs (if no HTTP log format matched)
  if "_grokparsefailure" not in [tags] {
    grok {
      match => {
        "message" => "\[%{TIMESTAMP_ISO8601:timestamp}\] (\[%{DATA:user}\])?\s+%{LOGLEVEL:log_level}\s+%{DATA:logger}:\s+%{GREEDYDATA:log_message}"
      }
      tag_on_failure => []
    }
  }
  
  if [response_code] {
    mutate {
      convert => {
        "response_code" => "integer"
        "response_size" => "integer"
        "http_version" => "float"
      }
      add_field => {
        "type" => "http_request"
      }
    }
  } else {
    mutate {
      add_field => {
        "type" => "jenkins_log"
      }
    }
  }
  
  if [timestamp] {
    date {
      match => ["timestamp", "dd/MMM/yyyy:HH:mm:ss Z", "ISO8601"]
      target => "@timestamp"
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "jenkins-logs-%{+YYYY.MM.dd}"
  }
}
